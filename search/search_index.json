{"config":{"lang":["es"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Workshop de Kubernetes","text":"<p>Bienvenidos al Workshop!</p> <p>En estos workshops vamos a usar Kubernetes en IBM Cloud para realizar diferentes tareas como ser:</p> <ul> <li>Desplegar un POD con Ubuntu</li> <li>Desplegar Graphana para monitoreo</li> <li>Desplegar PHP y MongoDB integrado</li> <li>Desplegar una app en Node</li> <li>Desplegar Wordpress</li> </ul>"},{"location":"#requisitos","title":"Requisitos","text":"<p>Lo siguiente es necesario para tener un entorno de desarrollo</p>"},{"location":"#1-ibm-cloud","title":"1. IBM Cloud","text":"<p>Asegurarse de contar con un IBM Cloud ID</p> <p>Sign up for IBM Cloud! </p>"},{"location":"#2-github","title":"2. GitHub","text":"<p>Ensure you have a GitHub account</p> <p>Sign up for GitHub</p>"},{"location":"#autor","title":"Autor","text":"<p>Tuve la oportunidad de crear este Workshop en el marco del Programa de Desarrollo de Contenido en Espa\u00f1ol, enfocado en IBM Cloud y Kubernetes, y que fuera publicado en el sitio de IBM Developer en Septiembre del 2020</p>"},{"location":"inicio/autor/","title":"Autor","text":"<p>Autor</p>"},{"location":"inicio/prereqs/","title":"Prereqs","text":"<p>Prerequisitos</p>"},{"location":"reference/mkdocs/","title":"Ejemplos de mkdocs","text":"<p>Esta p\u00e1gina incluye algunos buenos trucos que puedes hacer con <code>mkdocs</code>. Para obtener una lista completa de ejemplos, visite la documentaci\u00f3n de mkdocs.</p>"},{"location":"reference/mkdocs/#versionado","title":"Versionado","text":"<p>Para crear versiones, ejecute estos comandos</p> <pre><code>mike deploy --update-aliases 1.0 latest\nmike set-default latest\nmike deploy --update-aliases 2.0 latest\nmkdocs serve\n</code></pre>"},{"location":"reference/mkdocs/#codigo","title":"C\u00f3digo","text":"<pre><code>print(\"hello world!\")\n</code></pre>"},{"location":"reference/mkdocs/#codigo-con-numeros-de-linea","title":"C\u00f3digo con n\u00fameros de l\u00ednea","text":"<pre><code>def bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre>"},{"location":"reference/mkdocs/#codigo-con-destacados","title":"C\u00f3digo con destacados","text":"<pre><code>def bubble_sort(items):\nfor i in range(len(items)):\nfor j in range(len(items) - 1 - i):\nif items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre>"},{"location":"reference/mkdocs/#codigo-con-pestanas","title":"C\u00f3digo con pesta\u00f1as","text":"EncabezadoOtro encabezado <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\nprintf(\"Hello world!\\n\");\nreturn 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\n\nint main(void) {\nstd::cout &lt;&lt; \"Hello world!\" &lt;&lt; std::endl;\nreturn 0;\n}\n</code></pre>"},{"location":"reference/mkdocs/#mas-tabs","title":"M\u00e1s tabs","text":"WindowsMacOSLinux <p>Si est\u00e1s en windows descargar el archivo <code>Win32.zip</code> e instalalo.</p> <p>Correr <code>brew install foo</code>.</p> <p>Correr <code>apt-get install foo</code>.</p>"},{"location":"reference/mkdocs/#checklists","title":"Checklists","text":"<ul> <li> Lorem ipsum dolor sit amet, consectetur adipiscing elit</li> <li> Vestibulum convallis sit amet nisi a tincidunt<ul> <li> In hac habitasse platea dictumst</li> </ul> </li> </ul>"},{"location":"reference/mkdocs/#agregar-un-boton","title":"Agregar un bot\u00f3n","text":"<p>Lanzar el LAB</p> <p>Visitar IBM Developer</p> <p>Registrarse! </p>"},{"location":"reference/mkdocs/#call-outs","title":"Call outs","text":"<p>Tip</p> <p>Se puede usar <code>note</code>, <code>abstract</code>, <code>info</code>, <code>tip</code>, <code>success</code>, <code>question</code> <code>warning</code>, <code>failure</code>, <code>danger</code>, <code>bug</code>, <code>quote</code> or <code>example</code>.</p> <p>Note</p> <p>Una nota.</p> <p>Abstract</p> <p>Un abstract.</p> <p>Info</p> <p>Alguna info.</p> <p>Success</p> <p>Bien.</p> <p>Question</p> <p>Pregunta.</p> <p>Warning</p> <p>Cuidado.</p> <p>Danger</p> <p>Peligro.</p> <p>Example</p> <p>Un ejemplo.</p> <p>Bug</p> <p>Un error.</p>"},{"location":"reference/mkdocs/#call-outs-con-codigo","title":"Call outs con c\u00f3digo","text":"<p>Note</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <pre><code>def bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre> <p>Nunc eu odio eleifend, blandit leo a, volutpat sapien. Phasellus posuere in sem ut cursus. Nullam sit amet tincidunt ipsum, sit amet elementum turpis. Etiam ipsum quam, mattis in purus vitae, lacinia fermentum enim.</p>"},{"location":"reference/mkdocs/#formato","title":"Formato","text":"<p>Adem\u00e1s del t\u00edpico cursiva, y negrita ahora est\u00e1 soportado:</p> <ul> <li>resaltado</li> <li>subrayado</li> <li>tachado</li> </ul>"},{"location":"reference/mkdocs/#tablas","title":"Tablas","text":"OS por Aplicaci\u00f3n Usuario Password Windows VM <code>Administrator</code> <code>foo</code> Linux VM <code>root</code> <code>bar</code>"},{"location":"reference/mkdocs/#emojis","title":"Emojis","text":"<p>S\u00ed! Esto funciona!  </p>"},{"location":"reference/resources/","title":"Recursos adicionales","text":""},{"location":"reference/resources/#enlaces-interesantes","title":"Enlaces Interesantes","text":"<ul> <li>C\u00f3mo crear una cuenta gratuita en IBM Cloud</li> <li>Servicios de Kubernetes en IBM Cloud</li> <li>C\u00f3mo instalar el CLI de IBM Cloud</li> <li>Descripci\u00f3n general de kubectl</li> <li>Introducci\u00f3n a Docker</li> <li>Introducci\u00f3n a Node.js</li> <li>YAML Org</li> <li>YAML b\u00e1sico en Kubernetes</li> <li>C\u00f3mo usar YAML en Cl\u00faster de IBM</li> <li>Comunidad de Grafana </li> <li>Introduction to Node.js</li> <li>WordPress</li> <li>Descripci\u00f3n general de Secrets</li> </ul>"},{"location":"workshops/KubeBuntu/","title":"Ubuntu Lab","text":"<p>Como crear un \u00fanico Pod en un Cl\u00faster de Kubernetes.</p>"},{"location":"workshops/KubeBuntu/#introduction","title":"Introduction","text":"<p>C\u00f3mo se puede crear un \u00fanico Pod en un Cl\u00faster de Kubernetes en IBM Cloud? Un Pod es un grupo de uno o m\u00e1s contenedores, con recursos de red y almacenamiento compartidos y una especificaci\u00f3n de c\u00f3mo ejecutar los contenedores. Cuando un Pod ejecuta un solo contenedor, es como tener un entorno para un solo contenedor. Kubernetes administra los Pods en lugar de administrar los contenedores directamente.</p> <p>En este workshop vamos a ver c\u00f3mo implementar un Pod de Ubuntu en Kubernetes en IBM Cloud, con el objetivo de tener un Laboratorio para pruebas. Dado que los Pods son desechables, no es recomendable para usar en Producci\u00f3n. Crearemos un contenedor usando la \u00faltima imagen de Ubuntu en Docker Hub.</p>"},{"location":"workshops/KubeBuntu/#requisitos","title":"Requisitos","text":"<ul> <li>Una cuenta gratuita de IBM Cloud. Te podes registrar ac\u00e1 si no tenes una aun.</li> <li>Un Cluster de Kubernetes gratuito en IBM Cloud. Obtener ac\u00e1.</li> <li>Tener habilitados los comandos <code>ibmcloud</code> y <code>kubectl</code>. Configurar CLI.</li> </ul>"},{"location":"workshops/KubeBuntu/#tiempo-estimado","title":"Tiempo estimado","text":"<p>El tiempo estimado que puede llevar este workshop es menos de 30 minutos</p>"},{"location":"workshops/KubeBuntu/#pasos","title":"Pasos","text":"<ol> <li>Correr como Pod</li> <li>Correr como Implementaci\u00f3n</li> <li>Acceder a la consola de Ubuntu</li> <li>Instalar un paquete de prueba</li> </ol> <p>Se puede correr como Pod o como Implementaci\u00f3n, debajo se detallan las dos opciones.</p>"},{"location":"workshops/KubeBuntu/#1-correr-como-pod","title":"1. Correr como Pod:","text":"<p>Contenido de archivo <code>ubuntu-as-pod.yaml</code> para la creaci\u00f3n del Pod.   <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\nname: ubuntu\nlabels:\napp: ubuntu\nspec:\ncontainers:\n- name: ubuntu\nimage: ubuntu:latest\ncommand: [\"/bin/sleep\", \"3650d\"]\nimagePullPolicy: IfNotPresent\nrestartPolicy: Always\n</code></pre></p> <p>Aplicar la creaci\u00f3n del Pod: <pre><code>kubectl apply -f ubuntu-as-pod.yaml\n</code></pre>   Listar los Pods activos: <pre><code>kubectl get pods\n</code></pre></p>"},{"location":"workshops/KubeBuntu/#2-correr-como-implementacion","title":"2. Correr como Implementaci\u00f3n","text":"<p>Contenido del archivo <code>ubuntu-deployment.yaml</code> para la implementaci\u00f3n.   <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\ncreationTimestamp: null\nlabels:\napp: ubuntu\nname: ubuntu\nspec:\nreplicas: 1\nselector:\nmatchLabels:\napp: ubuntu\nstrategy: {}\ntemplate:\nmetadata:\ncreationTimestamp: null\nlabels:\napp: ubuntu\nspec:\ncontainers:\n- image: ubuntu\nname: ubuntu\ncommand: [\"/bin/sleep\", \"3650d\"]\nresources: {}\n</code></pre></p> <p>Desplegar la Implementaci\u00f3n: <pre><code>kubectl apply -f ubuntu-deployment.yaml\n</code></pre> Listar los pods activos: <pre><code>kubectl get pods\n</code></pre> Listar todo para ver la Implementaci\u00f3n y el Pod: <pre><code>kubectl get all\n</code></pre></p>"},{"location":"workshops/KubeBuntu/#3-acceder-a-la-consola-del-pod","title":"3. Acceder a la Consola del Pod:","text":"<p>Luego de confirmar que el Pod se est\u00e1 ejecutando, se puede acceder a la consola con el siguiente comando: <pre><code>kubectl exec --stdin --tty ubuntu -- /bin/bash\n</code></pre></p>"},{"location":"workshops/KubeBuntu/#4-prueba-instalar-paquetes-en-un-pod-de-ubuntu","title":"4. PRUEBA: Instalar paquetes en un pod de Ubuntu","text":"<p>Se puede usar la herramienta est\u00e1ndar de administraci\u00f3n de paquetes <code>apt</code> de Ubuntu.</p> <p>El siguiente ejemplo instala <code>telnet</code> en el contenedor de Ubuntu. <pre><code>root@ubuntu:/# apt update\nroot@ubuntu:/# apt install telnet\n</code></pre>   Probar funcionamiento de <code>telnet</code>: <pre><code>root@ubuntu:/# telnet 10.10.6.5   8080\n</code></pre></p>"},{"location":"workshops/KubeBuntu/#resumen","title":"Resumen","text":"<p>En este workshop pudimos ver como correr una instancia de Ubuntu en un solo Pod o en un Pod con una Implementaci\u00f3n. Una instacia de Ubuntu es muy \u00fatil para usar como Laboratorio de pruebas de paquetes o versiones diferentes de productos o aplicaciones. Tambi\u00e9n sirve como base para luego avanzar en otros aspectos de Kubernetes, como vol\u00famenes persistentes o servicios de red.</p>"},{"location":"workshops/KubeFana/","title":"Monitoreo en Kubernetes","text":"<p>Crear una instacia de Grafana en Kubernetes y acceder externamente</p>"},{"location":"workshops/KubeFana/#introduccion","title":"Introducci\u00f3n","text":"<p>Grafana es una herramienta de panel de c\u00f3digo abierto que se puede utilizar para mostrar m\u00e9tricas de diferentes sistemas. Se puede integrar con una variedad de fuentes de datos como Prometheus, InfluxDB Stackdriver, etc.</p> <p>En este workshop vamos a ver c\u00f3mo configurar un panel de Grafana en un Cl\u00faster de Kubernetes en IBM Cloud, usando Prometheus como herramienta de an\u00e1lisis de datos. Los siguientes pasos nos guiar\u00e1n para configurar una instancia de Grafana en funcionamiento. Adem\u00e1s veremos como crear un namespace para nuestro proyecto.</p>"},{"location":"workshops/KubeFana/#requisitos","title":"Requisitos","text":"<ul> <li>Una cuenta gratuita de IBM Cloud. Te podes registrar ac\u00e1 si no tenes una aun.</li> <li>Un Cluster de Kubernetes gratuito en IBM Cloud. Obtener ac\u00e1.</li> <li>Tener habilitados los comandos <code>ibmcloud</code> y <code>kubectl</code>. Configurar CLI.</li> </ul>"},{"location":"workshops/KubeFana/#tiempo-estimado","title":"Tiempo estimado","text":"<p>El tiempo estimado que puede llevar este workshop es de 30 minutos.</p>"},{"location":"workshops/KubeFana/#pasos","title":"Pasos","text":""},{"location":"workshops/KubeFana/#1-implementar-el-servicio-de-grafana-en-kubernetes","title":"1. Implementar el servicio de Grafana en Kubernetes","text":"<p>Crear un nuevo proyecto para el despliegue: <pre><code>kubectl create namespace monitoring\n</code></pre>   Implementar Grafana en el namespace que acabamos de crear, usando la \u00faltima imagen de Docker Hub: <pre><code>kubectl create deployment grafana -n monitoring --image=docker.io/grafana/grafana:latest\n</code></pre> Esto implementa Grafana en el cluster y lo inicializa, para ver el estado de la implementaci\u00f3n usar: <pre><code>kubectl get deployments -n monitoring\n</code></pre></p>"},{"location":"workshops/KubeFana/#2-exponer-el-servicio-de-grafana-usando-nodeport","title":"2. Exponer el servicio de Grafana usando NodePort","text":"<p>Tenemos que exponer el servicio via NodePort para que podamos acceder externamente, esto se logra con el siguiente comando:</p> <p><pre><code>kubectl -n monitoring expose deployment grafana --type=\"NodePort\" --port 3000\n</code></pre>   Esto crea el servicio y expone el puerto 3000, que es el puerto por defecto para Grafana. Para ver si el servicio ha sido expuesto correctamente: <pre><code>$ kubectl get service -n monitoring\nNAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE\ngrafana   NodePort   172.21.61.27   &lt;none&gt;        3000:32309/TCP   6d19h\n</code></pre>   Este y el siguiente comando pueden ser usados para encontrar el puerto externo que ha sido expuesto internamente, en este caso es el puerto <code>32309</code>. <pre><code>kubectl describe service -n monitoring|grep NodePort\n</code></pre>   Para obtener la IP P\u00fablica:</p> <p><pre><code>$ kubectl get nodes -o wide\nNAME            STATUS   ROLES    AGE   VERSION       INTERNAL-IP     EXTERNAL-IP\n10.131.75.187   Ready    &lt;none&gt;   17d   v1.19.9IKS   10.131.75.187   169.57.53.40\n</code></pre>   En este ejemplo, la IP p\u00fablica es: <code>169.57.53.40</code></p>"},{"location":"workshops/KubeFana/#3-acceder-al-panel-web-de-grafana","title":"3. Acceder al panel web de Grafana","text":"<p>Felicitaciones! Ahora podemos usar el enlace http://[Public IP]:[PORT] para acceder al servicio de la instacia de Grafana en nuestro Cl\u00faster de Kubernetes.</p> <p>Para este ejemplo, la URL es: <code>http://169.57.53.40:32309</code>. Esto abre la p\u00e1gina inicial de Grafana que requeire acceso. El usuario y contrase\u00f1a por defecto es <code>admin/admin</code>. En el primer ingreso es necesario cambiar la contrase\u00f1a.</p>"},{"location":"workshops/KubeFana/#4-probar-grafana","title":"4. Probar Grafana","text":"<p>Necesitamos probar la instancia de Grafana para ver si funciona correctamente. La manera m\u00e1s sencilla de hacer esto es usar \"theTestData DB\" la cual nos da ejemplos de visualizaci\u00f3n de datos. Para esto, en nuestro panel de Grafana hacer lo siguiente:</p> <ul> <li> <p>Hacer click en \"Create your first data source\" y elegir \"TestData DB\". Click en \"Save and test\".</p> </li> <li> <p>Hacer click en \"Create a new dashboard\" para crear un nuevo Panel.</p> </li> <li> <p>Para ver el panel con informaci\u00f3n, hacer click en \"heat map\" o \"graph\".</p> </li> </ul> <p>Hay muchas plantillas disponibles para crear paneles con funcionalidades que aplican para una variada cantidad de ambientes. Se pueden encontrar plantillas ac\u00e1..</p>"},{"location":"workshops/KubeFana/#5-monitorear-nuestro-cluster-de-kubernetes-con-nuestra-instancia-de-grafana","title":"5. Monitorear nuestro Cl\u00faster de Kubernetes con nuestra instancia de Grafana","text":"<ol> <li>Obtener el ID de esta plantilla p\u00fablica haciendo Click en \"Copy ID to Clipboard\".</li> <li>En nuestro panel de Grafana hacer click en Import.</li> <li>Ingresar el ID obtenido en el punto 1.</li> <li>Hacer click en Load.</li> <li>Hacer click en import para importar el panel. Esto nos llevar\u00e1 al panel con las m\u00e9tricas de nuestro Cl\u00faster.</li> </ol>"},{"location":"workshops/KubeFana/#resumen","title":"Resumen","text":"<p>Grafana es una herramienta muy ligera y poderosa para visualizaci\u00f3n de cargas de trabajo. Se puede integrar con varias herramientas de monitoreo y se adapta en diferentes escenarios. Esto incluye sistemas en la nube, entornos de red y contenedores.</p>"},{"location":"workshops/KubeMongo/","title":"PHP con MongoDB","text":"<p>Aplicaci\u00f3n PHP con MongoDB en Kubernetes</p>"},{"location":"workshops/KubeMongo/#introduccion","title":"Introducci\u00f3n","text":"<p>En este workshop vamos a ver c\u00f3mo implementar una aplicaci\u00f3n PHP tipo Libro de Visitas con varios niveles utilizando Kubernetes y Docker, con una instancia \u00fanica de MongoDB para almacenar las  entradas del libro de visitas y varias instancias de frontend web.</p>"},{"location":"workshops/KubeMongo/#requisitos","title":"Requisitos","text":"<ul> <li>Una cuenta gratuita de IBM Cloud. Te podes registrar ac\u00e1 si no tenes una aun.</li> <li>Un Cluster de Kubernetes gratuito en IBM Cloud. Obtener ac\u00e1.</li> <li>Tener habilitados los comandos <code>ibmcloud</code> y <code>kubectl</code>. Configurar CLI.</li> </ul>"},{"location":"workshops/KubeMongo/#tiempo-estimado","title":"Tiempo estimado","text":"<p>El tiempo estimado que puede llevar este workshop es de 30 minutos</p>"},{"location":"workshops/KubeMongo/#pasos","title":"Pasos","text":"<ol> <li>Implementar MongoDB.</li> <li>Crear el Servicio de MongoDB</li> <li>Configurar y exponer la interfaz del libro de visitas</li> <li>Creando el Servicio Frontend</li> <li>EXTRA: Escalar el servicio Frontend</li> </ol>"},{"location":"workshops/KubeMongo/#1-iniciar-la-base-de-datos-de-mongodb","title":"1. Iniciar la base de datos de MongoDB","text":"<p>Creaci\u00f3n de la implementaci\u00f3n de MongoDB. El archivo <code>mongo-deployment.yaml</code> especifica un controlador que ejecuta una \u00fanica r\u00e9plica de MongoDB.</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\nname: mongo\nlabels:\nname: mongo\ncomponent: backend\nspec:\nselector:\nmatchLabels:\nname: mongo\ncomponent: backend\nreplicas: 1\ntemplate:\nmetadata:\nlabels:\nname: mongo\ncomponent: backend\nspec:\ncontainers:\n- name: mongo\nimage: mongo:4.2\nargs:\n- --bind_ip\n- 0.0.0.0\nresources:\nrequests:\ncpu: 100m\nmemory: 100Mi\nports:\n- containerPort: 27017\n</code></pre> <p>Para aplicar la implementaci\u00f3n contenida en el archivo mongo-deployment.yaml, usar el siguiente comando:</p> <p><pre><code>kubectl apply -f mongo-deployment.yaml\n</code></pre> Ver la lista de Pods y verificar que el Pod de MongoDB est\u00e9 corriendo: <pre><code>kubectl get pods\n</code></pre> Para ver los registros de la implementaci\u00f3n del Pod, usar el siguiente comando: <pre><code>kubectl logs -f deployment/mongo\n</code></pre></p>"},{"location":"workshops/KubeMongo/#2-crear-el-servicio-de-mongodb","title":"2. Crear el Servicio de MongoDB","text":"<p>La aplicaci\u00f3n de Libro de Visitas debe comunicarse con MongoDB para escribir la informaci\u00f3n. Se debe aplicar un servicio que defina la pol\u00edtica de acceso para el tr\u00e1fico de la informaci\u00f3n. Esto se define con el contenido del archivo <code>mongo-service.yaml</code> que se detalla a continuaci\u00f3n:</p> <p><pre><code>apiVersion: v1\nkind: Service\nmetadata:\nname: mongo\nlabels:\nname: mongo\ncomponent: backend\nspec:\nports:\n- port: 27017\ntargetPort: 27017\nselector:\nname: mongo\ncomponent: backend\n</code></pre> Para aplicar el servicio con el archivo mongo-service.yaml usar el siguiente comando: <pre><code>kubectl apply -f mongo-service.yaml\n</code></pre> Ver la lista de Servicios y verificar que el Servicio de MongoDB est\u00e9 corriendo:</p> <pre><code>kubectl get service\n</code></pre>"},{"location":"workshops/KubeMongo/#3-configurar-y-exponer-la-interfaz-del-libro-de-visitas","title":"3. Configurar y exponer la interfaz del libro de visitas","text":"<p>El Libro de Visitas tiene una interfaz web que atiende las solicitudes HTTP escritas en PHP. Est\u00e1 configurado para conectarse al Servicio de MongoDB para almacenar entradas del Libro de Visitas.</p> <p>La implementaci\u00f3n del Frontend del Libro de Visitas se detalla en el contenido del archivo <code>frontend-deployment.yaml</code> a continuaci\u00f3n:</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\nname: frontend\nlabels:\nname: guestbook\ncomponent: frontend\nspec:\nselector:\nmatchLabels:\nname: guestbook\ncomponent: frontend\nreplicas: 3\ntemplate:\nmetadata:\nlabels:\nname: guestbook\ncomponent: frontend\nspec:\ncontainers:\n- name: guestbook\nimage: marcelorum/gb-frontend:v5\nresources:\nrequests:\ncpu: 100m\nmemory: 100Mi\nenv:\n- name: GET_HOSTS_FROM\nvalue: dns\nports:\n- containerPort: 80\n</code></pre> <p>Nota: Si la im\u00e1gen da error, probar con esta otra gcr.io/google-samples/gb-frontend:v5</p> <p>Aplicar la implementaci\u00f3n de frontend con el archivo frontend-deployment.yaml: <pre><code>kubectl apply -f frontend-deployment.yaml\n</code></pre> Ver la lista de Pods y verificar que las tres r\u00e9plicas de frontend se est\u00e9n ejecutando: <pre><code>kubectl get pods -l name=guestbook -l component=frontend\n</code></pre></p>"},{"location":"workshops/KubeMongo/#4-creando-el-servicio-frontend","title":"4. Creando el Servicio Frontend","text":"<p>Para que el Libro de Visitas sea accedido externamente, tenemos que crear un servicio y exponer el puerto externamente. Esto lo podemos hacer aplicando el contenido del archivo <code>frontend-service.yaml</code> que se detalla a continuaci\u00f3n: <pre><code>apiVersion: v1\nkind: Service\nmetadata:\nname: frontend\nlabels:\nname: guestbook\ncomponent: frontend\nspec:\ntype: LoadBalancer\nports:\n- port: 80\nselector:\nname: guestbook\ncomponent: frontend\n</code></pre></p> <p>Nota: La ventaja de estar usando Kubernetes en IBM Cloud, es que admite el uso de balanceadores de carga externos. Por eso usamos el siguiente componente <code>type: LoadBalancer</code>.</p> <p>Aplicar el servicio con el archivo frontend-service.yaml: <pre><code>kubectl apply -f frontend-service.yaml\n</code></pre> Verificar que el Servicio de Frontend est\u00e9 corriendo y ver el puerto: <pre><code>kubectl get service frontend\n</code></pre> Para obtener la IP P\u00fablica: <pre><code>kubectl get nodes -o wide\n</code></pre> Felicitaciones! Ahora podemos usar el enlace http://[Public IP]:[PORT] para acceder a la aplicaci\u00f3n.</p>"},{"location":"workshops/KubeMongo/#5-extra-escalar-el-servicio-frontend","title":"5. EXTRA: Escalar el servicio Frontend","text":"<p>Puede escalar hacia arriba o hacia abajo seg\u00fan sea necesario porque sus servidores est\u00e1n definidos como un Servicio que usa un controlador de implementaci\u00f3n.</p> <p>Para escalar el n\u00famero de Pods de Frontend usar el siguiente comando: <pre><code>kubectl scale deployment frontend --replicas=5\n</code></pre> Ver la lista de Pods y verificar el n\u00famero de Pods que estan corriendo: <pre><code>kubectl get pods\n</code></pre> Para reducir la cantidad de Pods usar el siguiente comando: <pre><code>kubectl scale deployment frontend --replicas=2\n</code></pre> Ver la lista de Pods y verificar el n\u00famero de Pods que estan corriendo: <pre><code>kubectl get pods\n</code></pre></p>"},{"location":"workshops/KubeMongo/#limpieza","title":"Limpieza","text":"<p>Al eliminar las implementaciones y los servicios, tambi\u00e9n se eliminan los pods en ejecuci\u00f3n. Se pueden utilizar etiquetas para eliminar varios recursos con un solo comando.</p> <p>Para eliminar todos los Pods, Implementaciones y Servicios, usar los siguientes comandos: <pre><code>kubectl delete deployment -l name=mongo\nkubectl delete service -l name=mongo\nkubectl delete deployment -l name=guestbook\nkubectl delete service -l name=guestbook\n</code></pre></p>"},{"location":"workshops/KubeMongo/#resumen-conclusion","title":"Resumen / Conclusi\u00f3n","text":"<p>En este workshop vimos como implementar una aplicaci\u00f3n web en PHP aplicada desde una imagen de Docker Hub, conectada a un servicio de base de datos MongoDB implementada en este mismo ejercicio y conectada a trav\u00e9s de un Servicio creado para tal fin. Adem\u00e1s vimos como escalar y reducir el n\u00famero de Pods de la aplicaci\u00f3n Frontend. Por \u00faltimo, limpiamos toda la implementaci\u00f3n.</p>"},{"location":"workshops/KubeNode/","title":"Desplegar con Docker","text":"<p>Desplegar una aplicaci\u00f3n desde una imagen propia de Docker en Kubernetes en IBM Cloud</p>"},{"location":"workshops/KubeNode/#introduccion","title":"Introducci\u00f3n","text":"<p>En este workshop vamos a ver el potencial de Docker y Kubernetes usados conjuntamente, aprenderemos a crear y modificar una im\u00e1gen de Docker, subirla al repositorio en Docker Hub y actualizarla. Luego vamos a usar esa imagen para hacer un despliegue en un Cluster de Kubernetes en IBM Cloud, revisar los pods y escalar la fuerza de trabajo. Por \u00faltimo vamos a exponer la aplicaci\u00f3n para poder acceder de manera externa, verificar el funcionamiento y tambi\u00e9n haremos algunos cambios en el servicio para probar la actualizaci\u00f3n del mismo y que podamos seguir accediendo a la aplicaci\u00f3n.</p>"},{"location":"workshops/KubeNode/#requisitos","title":"Requisitos","text":"<ul> <li>Sistema de gesti\u00f3n de paquetes de Node.js <code>npm</code>. Obtener npm/Node.js <p>Nota: En caso de no querer instalar Node.js, se puede usar el contenido del archivo KubeNode.zip. Descomprimirlo en el mismo directorio.</p> </li> <li>Docker y comando <code>docker</code> Obtener Docker</li> <li>Acceso a Docker Hub (en el caso de querer usar su propia imagen). Docker Hub <p>Nota: En caso de no querer usar una imagen propia, se puede usar la imagen marcelorum/node-hello-app creada para este fin.</p> </li> <li>Una cuenta gratuita de IBM Cloud. Te podes registrar ac\u00e1 si no tenes una aun.</li> <li>Un Cluster de Kubernetes gratuito. Obtener ac\u00e1</li> <li>Tener habilitados los comandos <code>ibmcloud</code> y <code>kubectl</code>. Configurar CLI</li> </ul>"},{"location":"workshops/KubeNode/#tiempo-estimado","title":"Tiempo estimado","text":"<p>El tiempo estimado que puede llevar este workshop es de 30 a 60 minutos con todos los requerimientos.</p>"},{"location":"workshops/KubeNode/#este-workshop-se-divide-en-tres-secciones","title":"Este workshop se divide en tres secciones","text":"<ol> <li>Node App</li> <li>Docker</li> <li>Kubernetes</li> </ol>"},{"location":"workshops/KubeNode/#1-node-app","title":"1. Node App","text":"<p>Nota: En caso de usar el contenido del archivo KubeNode.zip, saltar este paso.</p> <ol> <li> <p>En el directorio del proyecto, crear un paquete vac\u00edo e inicializar Node.js: <pre><code>npm init -y\n</code></pre></p> </li> <li> <p>Instalar el modulo para aplicaciones web de Node.js Express: <pre><code>npm install express\n</code></pre></p> </li> <li> <p>Dejar en el mismo directorio el archivo <code>index.js</code></p> <p>Contenido del archivo <code>index.js</code> para la implementaci\u00f3n. <pre><code>const express = require('express')\nconst os = require('os')\n\nconst app = express()\napp.get('/', (req, res) =&gt; {\nres.send(`Hola a todos desde ${os.hostname()}!`)\n})\n\nconst port = 3000\napp.listen(port, () =&gt; console.log(`listening on port ${port}`))\n</code></pre></p> </li> </ol>"},{"location":"workshops/KubeNode/#2-docker","title":"2. Docker","text":""},{"location":"workshops/KubeNode/#caso-1-con-imagen-propia","title":"Caso 1: Con imagen propia","text":"<ol> <li> <p>Vamos a usar el archivo <code>dockerfile</code> que tiene que estar en el mismo directorio que se est\u00e1 utilizando.</p> <p>Contenido del archivo <code>dockerfile</code> para la implementaci\u00f3n. <pre><code>FROM node:13-alpine\n\nWORKDIR /app\n\nCOPY package.json ./\n\nRUN npm install --production\n\nCOPY . .\n\nEXPOSE 3000\n\nCMD node index.js\n</code></pre></p> </li> <li> <p>Construir la imagen Docker: <pre><code>docker build -t &lt;dockeruser&gt;/node-hello-app .\n</code></pre></p> </li> <li> <p>Correr el contenedor localmente para probar: <pre><code>docker run --rm -d -p 3000:3000 &lt;dockeruser&gt;/node-hello-app\n</code></pre></p> </li> <li> <p>Revisar los contenedores que est\u00e1n corriendo: <pre><code>docker ps\n</code></pre></p> <p>Nota: Se puede revisar en http://localhost:3000</p> </li> <li> <p>Terminar las tareas de contenedor: <pre><code>docker stop &lt;CONTAINER_ID&gt;\ndocker stop $(docker ps -a -q)\n</code></pre></p> </li> <li> <p>Subir la imagen al repositorio en Docker Hub: <pre><code>docker push &lt;dockeruser&gt;/node-hello-app\n</code></pre></p> </li> </ol>"},{"location":"workshops/KubeNode/#caso-2-con-otra-imagen","title":"Caso 2: Con otra imagen","text":"<ol> <li> <p>Vamos a usar la imagen <code>marcelorum/node-hello-app</code> creada para este fin.</p> <p>Traer la im\u00e1gen del registro: <pre><code>docker pull marcelorum/node-hello-app\n</code></pre></p> </li> <li> <p>Correr el contenedor localmente para probar: <pre><code>docker run --rm -d -p 3000:3000 marcelorum/node-hello-app\n</code></pre></p> </li> <li> <p>Revisar los contenedores que est\u00e1n corriendo: <pre><code>docker ps\n</code></pre></p> <p>Nota: Se puede revisar en http://localhost:3000</p> </li> <li> <p>Terminar las tareas de contenedor: <pre><code>docker stop &lt;CONTAINER_ID&gt;\ndocker stop $(docker ps -a -q)\n</code></pre></p> </li> </ol>"},{"location":"workshops/KubeNode/#extra-prueba-de-actualizacion","title":"EXTRA: Prueba de actualizaci\u00f3n:","text":"<ul> <li>Editar el archivo <code>index.js</code> y reemplazar la palabra Hola por la palabra Hello.</li> <li>Reconstruir la imagen y prestar atenci\u00f3n del uso de las capas anteriores:   <pre><code>docker build -t &lt;dockeruser&gt;/node-hello-app .\n</code></pre></li> </ul>"},{"location":"workshops/KubeNode/#3-kubernetes","title":"3. Kubernetes","text":"<ol> <li> <p>Ver los nodos que se est\u00e1n ejecutando: <pre><code>kubectl get nodes\n</code></pre></p> </li> <li> <p>Crear un despliegue usando la imagen que creamos: <pre><code>kubectl create deployment --image &lt;dockeruser&gt;/node-hello-app node-app\n</code></pre> <pre><code>kubectl create deployment --image marcelorum/node-hello-app node-app\n</code></pre></p> <p>Nota: En caso de usar la imagen ya creada marcelorum/node-hello-app.</p> </li> <li> <p>Exponer el despliegue como una replica NodePort: <pre><code>kubectl expose deployment node-app --type=NodePort --port 3000\n</code></pre></p> </li> <li> <p>Revisar el servicio creado y el puerto asignado: <pre><code>kubectl get services\n</code></pre></p> </li> <li> <p>Para obtener la IP P\u00fablica: <pre><code>kubectl get nodes -o wide\n</code></pre> Felicitaciones! Ahora podemos usar el enlace http://[Public IP]:[PORT] para acceder al servicio.</p> </li> </ol>"},{"location":"workshops/KubeNode/#extra-prueba-de-esfuerzo","title":"EXTRA: Prueba de esfuerzo:","text":"<ul> <li>Listar los pods activos:   <pre><code>kubectl get pods\n</code></pre></li> <li>Escalar hasta 3 replicas:   <pre><code>kubectl scale deployment node-app --replicas 3\n</code></pre></li> <li>Listar los pods activos:   <pre><code>kubectl get pods\n</code></pre></li> </ul>"},{"location":"workshops/KubeNode/#extra-prueba-de-modificacion-del-servicio","title":"EXTRA: Prueba de modificaci\u00f3n del Servicio:","text":"<ul> <li> <p>Editar el servicio:   <pre><code>kubectl edit service node-app\n</code></pre></p> <p>Nota: Se sale del editor con :wq</p> </li> <li> <p>Reemplazar el puerto: <code>port: 3000</code> por <code>port: 80</code></p> </li> <li>Reemplazar el tipo: <code>type: NodePort</code> por <code>type: LoadBalancer</code></li> <li>Verificar que el servicio se haya actualizado:   <pre><code>kubectl get service\n</code></pre></li> <li>Usar el enlace http://[Public IP]:[PORT] para verificar.</li> </ul>"},{"location":"workshops/KubeNode/#resumen","title":"Resumen","text":"<p>En este workshop aprendimos a crear una imagen de Docker y subirla al repositorio, luego usar esa imagen para hacer un despliegue en un Cluster de Kubernetes en IBM Cloud. Adem\u00e1s vimos el comportamiento al realizar modificaciones en la imagen de Docker y en los Servicios de Kubernetes y tambi\u00e9n a escalar la aplicaci\u00f3n con m\u00e1s r\u00e9plicas.</p>"},{"location":"workshops/KubePress/","title":"WordPress en Kubernetes","text":"<p>Desplegar WordPress en Kubernetes en IBM Cloud</p>"},{"location":"workshops/KubePress/#introduccion","title":"Introducci\u00f3n","text":"<p>En este workshop vamos a ver el potencial de un Cluster de Kubernetes en IBM Cloud y aprender a desplegar uno de los m\u00e1s conocidos frameworks de sitios webs como lo es WordPress. Hay que tener en cuenta que el Cluster de Kubernetes de la cuenta gratuita de IBM Cloud expira a los 30 d\u00edas, tiempo suficiente para poder realizar varias pruebas y testear la tecnolog\u00eda.</p> <p>Cada componente se ejecuta en un contenedor o grupo de contenedores por separado. WordPress representa una aplicaci\u00f3n t\u00edpica de varios niveles y cada componente tendr\u00e1 sus propios contenedores. Los contenedores de WordPress ser\u00e1n el nivel de frontend y el contenedor MySQL ser\u00e1 el nivel de base de datos / backend para WordPress.</p>"},{"location":"workshops/KubePress/#objetivos","title":"Objetivos","text":"<ul> <li>Crear y definir un Volumen Persistente.</li> <li>Crear un Secret para proteger informaci\u00f3n sensible.</li> <li>Crear un despliegue de WordPresss.</li> <li>Crear un despliegue de una base de datos MySQL.</li> </ul>"},{"location":"workshops/KubePress/#requisitos","title":"Requisitos","text":"<ul> <li>Una cuenta gratuita de IBM Cloud. Te podes registrar ac\u00e1 si no tenes una aun.</li> <li>Un Cluster de Kubernetes gratuito. Obtener ac\u00e1</li> <li>Tener habilitados los comandos <code>ibmcloud</code> y <code>kubectl</code>. Configurar CLI</li> </ul>"},{"location":"workshops/KubePress/#tiempo-estimado","title":"Tiempo estimado","text":"<p>El tiempo estimado que puede llevar este workshop es menos de 30 minutos</p>"},{"location":"workshops/KubePress/#pasos-para-desplegar-en-ibm-cloud","title":"Pasos para Desplegar en IBM Cloud","text":"<ol> <li>Configurar Secrets para MySQL</li> <li>Crear volumenes persistentes locales</li> <li>Crear los servicios de despliegue para WordPress y MySQL</li> <li>Acceder al link externo de WordPress</li> </ol>"},{"location":"workshops/KubePress/#1-configurar-secret-para-mysql","title":"1. Configurar Secret para MySQL","text":"<p>Secrets en Kubernetes permiten almacenar y administrar informaci\u00f3n confidencial, como contrase\u00f1as y claves ssh, de forma segura y flexible.</p> <p>Crear un Secret con el siguiente comando (cambiar por su contrase\u00f1a): <pre><code>kubectl create secret generic mysql-pass --from-literal=password='tucontraseniasegura'\n</code></pre></p>"},{"location":"workshops/KubePress/#2-crear-volumenes-persistentes-locales","title":"2. Crear volumenes persistentes locales","text":"<p>Para guardar la informaci\u00f3n y los datos, m\u00e1s all\u00e1 de la vida \u00fatil de cada pod de Kubernetes, necesitamos crear un volumen persistente para la base de datos MySQL y la aplicaci\u00f3n de WordPress.</p> <p>Contenido del archivo <code>local-volumes.yaml</code> para la creaci\u00f3n del volume. <pre><code>---\napiVersion: v1\nkind: PersistentVolume\nmetadata:\nname: local-volume-1\nlabels:\ntype: local\nspec:\ncapacity:\nstorage: 20Gi\naccessModes:\n- ReadWriteOnce\nhostPath:\npath: /tmp/data/lv-1\npersistentVolumeReclaimPolicy: Recycle\n---\napiVersion: v1\nkind: PersistentVolume\nmetadata:\nname: local-volume-2\nlabels:\ntype: local\nspec:\ncapacity:\nstorage: 20Gi\naccessModes:\n- ReadWriteOnce\nhostPath:\npath: /tmp/data/lv-2\npersistentVolumeReclaimPolicy: Recycle\n</code></pre></p> <p>Crear el volumen persistente con el siguiente comando <pre><code>kubectl create -f local-volumes.yaml\n</code></pre></p>"},{"location":"workshops/KubePress/#3-crear-los-servicios-de-despliegue-para-wordpress-y-mysql","title":"3. Crear los servicios de despliegue para WordPress y MySQL","text":"<p>Para instalar el volumen persistente en el almacenamiento local del cluster, usar los secrets y crear los servicios para MySQL y WordPress, vamos a usar los archivos de configuraci\u00f3n <code>mysql-deployment.yaml</code> y <code>wordpress-deployment.yaml</code></p> <p>Contenido del archivo <code>mysql-deployment.yaml</code> para el servicio de mysql. <pre><code>apiVersion: v1\nkind: Service\nmetadata:\nname: wordpress-mysql\nlabels:\napp: wordpress\nspec:\nports:\n- port: 3306\nselector:\napp: wordpress\ntier: mysql\nclusterIP: None\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\nname: mysql-pv-claim\nlabels:\napp: wordpress\nspec:\naccessModes:\n- ReadWriteOnce\nresources:\nrequests:\nstorage: 20Gi\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\nname: wordpress-mysql\nlabels:\napp: wordpress\nspec:\nselector:\nmatchLabels:\napp: wordpress\ntier: mysql\nstrategy:\ntype: Recreate\ntemplate:\nmetadata:\nlabels:\napp: wordpress\ntier: mysql\nspec:\ncontainers:\n- image: mysql:5.6\nname: mysql\nenv:\n- name: MYSQL_ROOT_PASSWORD\nvalueFrom:\nsecretKeyRef:\nname: mysql-pass\nkey: password\nports:\n- containerPort: 3306\nname: mysql\nvolumeMounts:\n- name: mysql-persistent-storage\nmountPath: /var/lib/mysql\nvolumes:\n- name: mysql-persistent-storage\npersistentVolumeClaim:\nclaimName: mysql-pv-claim\n</code></pre></p> <p>Contenido del archivo <code>wordpress-deployment.yaml</code> para el servicio de WordPress. <pre><code>apiVersion: v1\nkind: Service\nmetadata:\nname: wordpress\nlabels:\napp: wordpress\nspec:\nports:\n- port: 80\nselector:\napp: wordpress\ntier: frontend\ntype: LoadBalancer\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\nname: wp-pv-claim\nlabels:\napp: wordpress\nspec:\naccessModes:\n- ReadWriteOnce\nresources:\nrequests:\nstorage: 20Gi\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\nname: wordpress\nlabels:\napp: wordpress\nspec:\nselector:\nmatchLabels:\napp: wordpress\ntier: frontend\nstrategy:\ntype: Recreate\ntemplate:\nmetadata:\nlabels:\napp: wordpress\ntier: frontend\nspec:\ncontainers:\n- image: wordpress:4.8-apache\nname: wordpress\nenv:\n- name: WORDPRESS_DB_HOST\nvalue: wordpress-mysql\n- name: WORDPRESS_DB_PASSWORD\nvalueFrom:\nsecretKeyRef:\nname: mysql-pass\nkey: password\nports:\n- containerPort: 80\nname: wordpress\nvolumeMounts:\n- name: wordpress-persistent-storage\nmountPath: /var/www/html\nvolumes:\n- name: wordpress-persistent-storage\npersistentVolumeClaim:\nclaimName: wp-pv-claim\n</code></pre></p> <p>Crear los servicios para MySQL y WordPress.</p> <pre><code>kubectl create -f mysql-deployment.yaml\nkubectl create -f wordpress-deployment.yaml\n</code></pre> <p>Para verificar que los los pods est\u00e9n corriendo, usar el siguiente comando para ver el nombre de los pods:</p> <pre><code>kubectl get pods\n</code></pre> <p>Esto deber\u00eda devolver la lista de pods del Cluster de Kubernetes.</p> <pre><code>NAME                               READY   STATUS    RESTARTS   AGE\nwordpress-57799cb7f8-prdxt         1/1     Running   0          31s\nwordpress-mysql-5896755cf4-mq5q5   1/1     Running   1          40s\n</code></pre>"},{"location":"workshops/KubePress/#4-acceder-al-link-externo-de-wordpress","title":"4. Acceder al link externo de WordPress","text":"<p>Para obtener la direcci\u00f3n IP de su cluster siga estos pasos:</p> <p>Para ver el nombre del Cluster: <pre><code>ibmcloud ks cluster ls\n</code></pre> Para ver la IP P\u00fablica: <pre><code>ibmcloud ks workers --cluster &lt;nombre_del_cluster&gt;\n</code></pre> El resultado es similar a este: <pre><code>OK\nID                                                       Public IP      Private IP      Flavor   State    Status   Zone    Version   \nkube-c1upsl3d07j9adhlggm0-ibmkubeclou-default-00000000   169.57.43.40   10.131.75.187   free     normal   Ready\n</code></pre> Para obtener el puerto: <pre><code>kubectl get services wordpress\n</code></pre></p> <p>El resultado es similar a este: <pre><code>NAME        TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE\nwordpress   LoadBalancer   172.21.160.82   &lt;pending&gt;     80:30180/TCP   23s\n</code></pre></p> <p>Felicitaciones! Ahora podemos usar el link http://[Public IP]:[PORT] para acceder al sitio de WordPress.</p> <p>Nota: Para este ejemplo, el enlace quedar\u00eda de esta forma http://169.57.43.40:30180</p>"},{"location":"workshops/KubePress/#resumen","title":"Resumen","text":"<p>En este workshop pudimos ver el potencial de Kuberneter en IBM Cloud y aprendimos a hacer un despliegue de WordPress con una base de datos MySQL, configurar los datos sensibles usando Secrets y generar volumenes persistentes para conservar la informaci\u00f3n.</p>"},{"location":"workshops/KubeThree/","title":"Kubernetes a fondo","text":"<p>Kubernetes en lo Profundo, tres elementos importantes</p>"},{"location":"workshops/KubeThree/#introduccion","title":"Introducci\u00f3n","text":"<p>En este workshop vamos a ver tres elementos que son muy importantes para ir profundizando en el uso de Kubernetes, m\u00e1s all\u00e1 de su uso para pruebas de laboratorio, pensando en un uso productivo y el aprovechamiento del potencial de esta herramienta. Vamos a ver c\u00f3mo configurar namespaces y poder ordernar proyectos, configurar entornos multi-containers y crear vol\u00famenes persistentes para poder retener informaci\u00f3n de los Pods.</p>"},{"location":"workshops/KubeThree/#requisitos","title":"Requisitos","text":"<ul> <li>Una cuenta gratuita de IBM Cloud. Registrar ac\u00e1.</li> <li>Un Cluster de Kubernetes gratuito en IBM Cloud. Obtener ac\u00e1.</li> <li>Tener habilitados los comandos <code>ibmcloud</code> y <code>kubectl</code>. Configurar CLI.</li> </ul>"},{"location":"workshops/KubeThree/#tiempo-estimado","title":"Tiempo estimado","text":"<p>El tiempo estimado que puede llevar este workshop es de 30 a 45 minutos con todos los requerimientos.</p>"},{"location":"workshops/KubeThree/#este-workshop-se-divide-en-tres-secciones","title":"Este workshop se divide en tres secciones","text":"<ol> <li>C\u00f3mo crear un namespace.</li> <li>C\u00f3mo crear un Pod multi-container</li> <li>C\u00f3mo crear un Volumen para Almacenamiento persistente</li> </ol>"},{"location":"workshops/KubeThree/#1-como-crear-un-namespace","title":"1. C\u00f3mo crear un namespace","text":"<p>Los namespaces son muy \u00fatiles para una mejor gesti\u00f3n de Kubernetes. En este workshop veremos como crear un nuevo namespace e implementar un pod en \u00e9l.</p> <p>En Kubernetes, un namespace se puede usar en entornos donde varios usuarios trabajan en diferentes equipos o proyectos. Con el uso de namespaces es posible dividir los recursos entre los usuarios sin que se produzca una colisi\u00f3n de nombres.</p> <p>Namespaces son una especie de cl\u00faster virtual, parecido a tener varias m\u00e1quinas virtuales y podemos tener varios namespaces en el mismo Cl\u00faster.</p> <p>Al crear un cl\u00faster de Kubernetes, se inician al menos tres espacios de nombres b\u00e1sicos:</p> <ul> <li>default: se utiliza para implementaciones sin namespace asignado</li> <li>kube-system: se utiliza para todo lo relacionado con el sistema Kubernetes</li> <li>kube-public: reservado solo para uso del sistema</li> </ul> <p>Para ver la lista de namespaces actuales usar el comando: <pre><code>kubectl get namespaces\n</code></pre> Ejemplo de mi Cl\u00faster de prueba: <pre><code>$ kubectl get namespaces\nNAME              STATUS   AGE\ndefault           Active   18d\nibm-cert-store    Active   18d\nibm-operators     Active   18d\nibm-system        Active   18d\nkube-node-lease   Active   18d\nkube-public       Active   18d\nkube-system       Active   18d\n</code></pre></p> <p>Vamos a crear un namespace llamado staging corriendo el siguiente comando: <pre><code>kubectl create namespace staging\n</code></pre> Vamos a implementar un Pod NGINX en el nuevo namespace <code>staging</code> con el siguiente comando: <pre><code>kubectl run nginx --image=nginx --namespace=staging\n</code></pre> Para ver si el Pod se ha implementado correctamente vamos a correr el siguiente comando: <pre><code>kubectl get pods --namespace=staging\n</code></pre> Nuestro Pod NGINX se est\u00e1 ejecutando.</p>"},{"location":"workshops/KubeThree/#extra-como-configurar-el-namespace-predeterminado","title":"EXTRA: C\u00f3mo configurar el namespace predeterminado","text":"<p>Para usar un namespace espec\u00edfico como predeterminado, para no tener que usar la opci\u00f3n <code>--amespace=NAMESPACE</code> en los comandos de implementaci\u00f3n, usar el siguiente comando: <pre><code>kubectl config set-context --current --namespace=NAMESPACE\n</code></pre></p> <p>Nota: NAMESPACE es el nombre del namespace que va a utilizar como predeterminado.</p>"},{"location":"workshops/KubeThree/#2-como-crear-un-pod-multi-container","title":"2. C\u00f3mo crear un Pod multi-container","text":"<p>Para crear un Pod multi-container vamos a utilizar el siguiente archivo <code>multi-container-pod.yml</code> con el siguietne contenido: <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\nname: multi-container-pod\nspec:\ncontainers:\n- name: container-1\nimage: nginx\nports:\n- containerPort: 80  - name: container-2\nimage: alpine\ncommand: [\"watch\", \"wget\", \"-qO-\", \"localhost\"]\n</code></pre> Este archivo tiene una definici\u00f3n para 2 contenedores que compartir\u00e1n la misma red, recursos y vol\u00famen. Para crear un Pod de contenedores m\u00faltiples usar el siguiente comando: <pre><code>kubectl create -f multi-container-pod.yml\n</code></pre> Para ver los pods que estan corriendo, usar el siguiente comando: <pre><code>kubectl get pods\n</code></pre> Para ver el detalle del Pod: <pre><code>kubectl describe pod multi-container-pod\n</code></pre> Ac\u00e1 vamos a poder ver los detalles de los dos contenedores que contiene. Los contenedores contenedor-1 y contenedor-2. Ambos pertenecen al mismo grupo.</p> <p>Para verificar los registros de un contenedor en particular, puede agregar el nombre del contenedor al comando: <pre><code>kubectl logs multi-container-pod container-1\n</code></pre></p> <p>Si el nombre del contenedor no se proporciona en el comando, aparece un error en el que se le indica que especifique el nombre del contenedor. Se puede especificar el nombre de un \u00fanico contenedor y no se pueden especificar varios contenedores en el comando para obtener los registros, los siguientes dos comandos fallan: <pre><code>kubectl logs multi-container-pod\nkubectl logs multi-container-pod container-1 container-2\n</code></pre> El comando para iniciar sesi\u00f3n en el pod no funciona cuando hay varios contenedores dentro de un solo pod, el siguiente comando falla: <pre><code>kubectl exec -it multi-container-pod /bin/bash\n</code></pre> Para iniciar sesi\u00f3n en el contenedor en particular, necesitamos especificar el nombre del contenedor en el comando, adem\u00e1s de que no se puede iniciar sesi\u00f3n en 2 pods al mismo tiempo: <pre><code>kubectl exec -it multi-container-pod -c container-1 /bin/bash\n</code></pre> Cuando el Pod ya no sea necesario, se puede eliminar y limpiar con el siguiente comando: <pre><code>kubectl delete pod multi-container-pod\n</code></pre></p>"},{"location":"workshops/KubeThree/#3-configura-un-volume-para-almacenamiento-persistente-con-un-pod","title":"3. Configura un Volume para Almacenamiento persistente con un Pod","text":"<p>Vamos a ver c\u00f3mo configurar un Pod para usar un Vol\u00famen como almacenamiento. Los archivos de un contenedor existen mientras el Contenedor exista. Cuando un Contenedor es destruido o reiniciado, los cambios realizados se pierden. Para preservar datos se puede usar un Volume.</p> <p>Va a ser un Pod que ejecuta un \u00fanico Contenedor. El Volume es de tipo emptyDir y se va a mantener incluso cuando el Contenedor sea destruido y reiniciado. <code>volumen.yaml</code>: <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\nname: redis\nspec:\ncontainers:\n- name: redis\nimage: redis\nvolumeMounts:\n- name: redis-storage\nmountPath: /data/redis\nvolumes:\n- name: redis-storage\nemptyDir: {}\n</code></pre></p> <p>Implementar el Pod: <pre><code>kubectl apply -f volumen.yaml\n</code></pre> Ver los Pods que est\u00e1n corriendo: <pre><code>kubectl get pods\n</code></pre> Vamos a inicar sesi\u00f3n en el Contenedor: <pre><code>kubectl exec -it redis -- /bin/bash\n</code></pre> Vamos a crear un archivo de prueba en /data/redis: <pre><code>$ cd /data/redis/\n$ echo Hola &gt; prueba.txt\n</code></pre> Vamos a listar los procesos en ejecuci\u00f3n: <pre><code>$ apt-get update\n$ apt-get install procps\n$ ps aux\n</code></pre> Ahora debemos matar el proceso de Redis <code>redis-server</code>: <pre><code>$ kill &lt;pid&gt;\n</code></pre></p> <p>Donde  es el ID de proceso (PID) de Redis. <p>Viendo los Pods con <code>kubectl get pods</code> podemos observar los cambios en el Pod de Redis. RESTARTS cuenta 1. El Contenedor ha sido destruido y reiniciado.</p> <p>Vamos a inicar sesi\u00f3n en el Contenedor nuevamente: <pre><code>kubectl exec -it redis -- /bin/bash\n</code></pre> Vamos a ir a /data/redis para verifica que el archivo de prueba aun existe: <pre><code>$ cd /data/redis/\n$ ls\n</code></pre> Cuando el Pod ya no sea necesario, se puede eliminar y limpiar con el siguiente comando: <pre><code>kubectl delete pod redis\n</code></pre></p>"},{"location":"workshops/KubeThree/#resumen-conclusion","title":"Resumen / Conclusi\u00f3n","text":"<p>En este workshop vimos como ordenar el trabajo en proyectos con el uso de namespaces, aprendimos c\u00f3mo crear un pod de contenedores m\u00faltiples, obtener registros de un contenedor en particular e iniciar sesi\u00f3n en un solo contenedor. Adem\u00e1s vimos como crear un almacenamiento local proporcionado por emptyDir, Kubernetes soporta diferentes tipos de soluciones de almacenamiento por red y se encarga de todos los detalles, tal como montar y desmontar los dispositivos en los nodos del cl\u00faster.</p>"}]}